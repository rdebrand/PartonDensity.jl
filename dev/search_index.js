var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [PartonDensity]","category":"page"},{"location":"api/#PartonDensity.PDFParameters","page":"API","title":"PartonDensity.PDFParameters","text":"PDFParameters\n\nParameters of the input PDFs.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.QCDNUMGrid","page":"API","title":"PartonDensity.QCDNUMGrid","text":"QCDNUMGrid\n\nStruct for holding the QCDNUM grid parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.QCDNUMParameters","page":"API","title":"PartonDensity.QCDNUMParameters","text":"QCDNUMParameters\n\nStruct for holding all QCDNUM Parameters. \n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.QuarkCoefficients","page":"API","title":"PartonDensity.QuarkCoefficients","text":"QuarkCoefficients\n\nQuark coefficients for structure function  calculations.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.SPLINTParameters","page":"API","title":"PartonDensity.SPLINTParameters","text":"SPLINTParameters\n\nStruct for storage of parameters used with SPLINT package of QCDNUM.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.SplineAddresses","page":"API","title":"PartonDensity.SplineAddresses","text":"SplineAddresses\n\nLookup table for addresses of different  structure function splines.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity._fun_xsec_i-Tuple{Any, Any}","page":"API","title":"PartonDensity._fun_xsec_i","text":"_fun_xsec_i(ix iq)\n\nInput function for cross section spline. Must be wrapped for interface to SPLINT.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.dd_xsecnc_xq2-Tuple{Array{Float64, N} where N, Array{Float64, N} where N}","page":"API","title":"PartonDensity.dd_xsecnc_xq2","text":"dd_xsecnc_xq2(x_bin_cen, q2_bin_cen)\n\nDouble differential cross section for all x and  q2 bins. NB: modifications needed to include pol and order.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.dd_xsecnc_xq2_i-NTuple{5, Float64}","page":"API","title":"PartonDensity.dd_xsecnc_xq2_i","text":"dd_xsecnc_xq2_i(x, q2)\n\nDouble differential cross section for single  x and q2 values.  NB: modifications needed to include pol and order.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.f2_lo-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.f2_lo","text":"f2_lo(x, q2)\n\nCalculate the f2_lo structure function term.  To be run after the evolution of PDFs with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.fl_lo-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.fl_lo","text":"fl_lo(x, q2)\n\nCalculate the fl_lo structure function term. To be run after the evolution of PDFs with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.forward_model-Tuple{PDFParameters, QCDNUMParameters, SPLINTParameters, QuarkCoefficients}","page":"API","title":"PartonDensity.forward_model","text":"forward_model(pdf_params, qcdnum_grid, \n              splint_params, quark_coeffs)\n\nGo from input PDF parameters to the expected number of events in bins.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.forward_model_init-Tuple{QCDNUMGrid, QCDNUMParameters, SPLINTParameters}","page":"API","title":"PartonDensity.forward_model_init","text":"forward_model_init(qcdnum_grid, qcdnum_params)\n\nInitialise forward model. Initialises QCDNUM and builds weight tables to  save time in subsequent iterations. Must be called prior to first instance  of forward_model().\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.get_dirichlet_samples-Tuple{Float64, Float64, Float64, Float64, Integer, Vector{Float64}}","page":"API","title":"PartonDensity.get_dirichlet_samples","text":"get_dirichlet_samples(λ_u, K_u, λ_d, K_d, seed, weights)\n\nGiven valance shape parameters and weights, get samples θ that are correctly scaled. \n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.get_scaled_θ-Tuple{Float64, Float64, Float64, Float64, Vector{Float64}}","page":"API","title":"PartonDensity.get_scaled_θ","text":"get_scaled_θ(λ_u, K_u, λ_d, K_d, θ_tmp)\n\nGiven a set of Dirichlet samples, θ_tmp, scale  according to the valence params.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.int_xtotx-Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Array{Float64, N} where N}","page":"API","title":"PartonDensity.int_xtotx","text":"int_xtotx(λ_u, K_u, λ_d, K_d, λ_g1, λ_g2, K_g, λ_q, θ)\n\nTotal integrated momentum density. Should equal 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.int_xtotx-Tuple{PDFParameters}","page":"API","title":"PartonDensity.int_xtotx","text":"int_xtotx(hyper_params)\n\nTotal integrated momentum density. Should equal 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.nc_propagator-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.nc_propagator","text":"nc_propagator(q2, x)\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.pd_read_sim-Tuple{String}","page":"API","title":"PartonDensity.pd_read_sim","text":"pd_read_sim(file_name)\n\nRead in the simulated truth and simulated data from HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.pd_write_sim-Tuple{String, PDFParameters, Dict{String, Any}}","page":"API","title":"PartonDensity.pd_write_sim","text":"pd_write_sim(file_name, pdf_params, sim_data)\n\nStore the simulation truth and simulated data in an HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.plot_data_space-Tuple{PDFParameters, Dict{String, Any}, Any, QCDNUMGrid, QCDNUMParameters, SPLINTParameters, QuarkCoefficients}","page":"API","title":"PartonDensity.plot_data_space","text":"plot_data_space(pdf_params, sim_data, samples, qcdnum_grid, \n                qcdnum_params, splint_params, quark_coeffs)\n\nCompare truth and posterior samples in the data space.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.plot_input_pdfs","page":"API","title":"PartonDensity.plot_input_pdfs","text":"plot_input_pdfs(hyper_params, xmin, xmax, nx)\n\nPlot the input PDFs defined by hyper_params over  the given x range.   \n\n\n\n\n\n","category":"function"},{"location":"api/#PartonDensity.plot_model_space-Tuple{PDFParameters, Any}","page":"API","title":"PartonDensity.plot_model_space","text":"plot_model_space(pdf_params, samples)\n\nCompare truth and posterior samples in the model space.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.rxsecnc_xq2-Tuple{Array{Float64, N} where N, Array{Float64, N} where N}","page":"API","title":"PartonDensity.rxsecnc_xq2","text":"rxsecnc_xq2(x, q2)\n\nReduced cross section for all bins.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.rxsecnc_xq2_i-NTuple{5, Float64}","page":"API","title":"PartonDensity.rxsecnc_xq2_i","text":"rxsecnc_xq2_i(x, q2)\n\nReduced cross section for single x, q2.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_dv_x-Tuple{Float64, Float64, Float64}","page":"API","title":"PartonDensity.x_dv_x","text":"x_dv_x(x, λ_d, K_d)\n\nMomentum density of d valence component. Beta function     Ad x^λd (1 - x)^Kd Ad is set by λd and Kd.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_g_x-NTuple{6, Float64}","page":"API","title":"PartonDensity.x_g_x","text":"    x_g_x(x, λ_g1, λ_g2, K_g, w1, w2)\n\nMomentum density of gluon component.     Ag1 x^λg1 (1 - x)^Kg + Ag2 x^λ_g2 Amplitudes are set by weights w1 and w2.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_q_x-Tuple{Float64, Float64, Float64}","page":"API","title":"PartonDensity.x_q_x","text":"x_q_x(x, λ_q, w)\n\nMomentum density of non-valence quark component.     Aq x^λq Amplitude is set by weight w\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_uv_x-Tuple{Float64, Float64, Float64}","page":"API","title":"PartonDensity.x_uv_x","text":"x_uv_x(x, λ_u, K_u)\n\nMomentum density of u valence component. Beta function      Au x^λu (1-x)^Ku Au is set by λu and Ku.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.xf3_lo-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.xf3_lo","text":"xf3_lo(x, q2)\n\nCalculate the xf3_lo structure function term. To be run after the evolution of PDFs with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.xtotx-Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Array{Float64, N} where N}","page":"API","title":"PartonDensity.xtotx","text":"x_total_x(x, λ_u, K_u, λ_d, K_d, λ_g1, λ_g2, K_g, λ_q, θ)\n\nTotal momentum density.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.xtotx-Tuple{Float64, PDFParameters}","page":"API","title":"PartonDensity.xtotx","text":"x_total_x(x, hyper_params)\n\nTotal momentum density.\n\n\n\n\n\n","category":"method"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/prior_bat_implementation.jl\"","category":"page"},{"location":"prior_bat_implementation/#Prior-model-implementation-in-BAT.jl","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"In this notebook, the implementation of the prior model is demonstrated, starting with a simple two-component model and scaling up to the full 9 component model.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"using Distributions, StatsBase, LinearAlgebra\nusing Plots, SpecialFunctions, Printf, Random, ValueShapes\nusing BAT, DensityInterface\nconst sf = SpecialFunctions;\n\ngr(fmt=:png);\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/#Simple-two-component-model:-gluons","page":"Prior model implementation in BAT.jl","title":"Simple two-component model: gluons","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"First we start with a simpler two-component model, and show all the steps explicity for clarity.","category":"page"},{"location":"prior_bat_implementation/#Forward-model","page":"Prior model implementation in BAT.jl","title":"Forward model","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"The gluon distributions are parametrised by","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"x g(x) = A_g1 x^lambda_g1(1-x)^K_g + A_g2 x^lambda_g2(1-x)^5","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We also want to impose","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"int_0^1 x g(x) dx = A_g1 B(lambda_g1+1 K_g+1) + A_g2 B(lambda_g2+1 1+5) = 1","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"with B(.,.) the Beta function.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Start by defining some useful functions:","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"function xg1x(x, λ_g1, K_g, θ_1)\n    A_g1 = θ_1 / sf.beta(λ_g1 + 1, K_g + 1)\n    return A_g1 * x^λ_g1 * (1 - x)^K_g\nend\n\nfunction xg2x(x, λ_g2, θ_2)\n    A_g2 = θ_2 / sf.beta(λ_g2 + 1, 5 + 1)\n    return A_g2 * x^λ_g2 * (1 - x)^5\nend\n\nfunction xgx(x, λ_g1, λ_g2, K_g, θ)\n    xg1 = xg1x(x, λ_g1, K_g, θ[1])\n    xg2 = xg2x(x, λ_g2, θ[2])\n    return xg1 + xg2\nend","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Choose true values for the high-level parameters and show what the resulting model looks like.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"θ = [0.5, 0.5]\nλ_g1 = 0.5 # rand(Uniform(0, 1))\nλ_g2 = -0.7 # rand(Uniform(-1, 0))\nK_g = 3 # rand(Uniform(2, 10))\ntruths = (θ = θ, λ_g1 = λ_g1, λ_g2 = λ_g2, K_g = K_g);\n\nA_g1 = θ[1] / sf.beta(λ_g1+1, K_g+1)\nA_g2 = θ[2] / sf.beta(λ_g2+1, 5+1);\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Check integral = 1","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"total = A_g1 * sf.beta(λ_g1+1, K_g+1) + A_g2 * sf.beta(λ_g2+1, 5+1)\nprint(\"Integral = \", total)","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Plot true model","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"x_grid = range(0, stop=1, length=50)\n\nxg1 = A_g1 * x_grid.^λ_g1 .* (1 .- x_grid).^K_g\nxg2 = A_g2 * x_grid.^λ_g2 .* (1 .- x_grid).^5\n\nplot(x_grid, [xg1x(x, λ_g1, K_g, θ[1]) for x in x_grid],\n      alpha=0.7, label=\"x g1(x)\", lw=3, color=\"green\")\nplot!(x_grid, [xg2x(x, λ_g2, θ[2]) for x in x_grid],\n     alpha=0.7, label=\"x g2(x)\", lw=3, color=\"blue\")\nplot!(x_grid, [xgx(x, λ_g1, λ_g2, K_g, θ) for x in x_grid],\n      alpha=0.7, label=\"x g1(x) + x g2(x)\", lw=3, color=\"red\")\nplot!(xlabel=\"x\")","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Now, for the purposes of testing the prior implementation, sample some data from this distribution assuming that the data are produced by integrating over the function in different bins, and multiplying by some factor. Then, plot the model and data to compare.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"seed = 42\nRandom.seed!(seed) # for reproducibility\n\nbins = 0.0:0.05:1.0\nbin_widths = bins[2:end] - bins[1:end-1]\nbin_centers = (bins[1:end-1] + bins[2:end]) / 2\n\nN = 1000\nnbins = size(bin_centers)[1]\n\nexpected_counts = zeros(nbins)\nobserved_counts = zeros(Integer, nbins)\nfor i in 1:nbins\n    xg = xgx(bin_centers[i], λ_g1, λ_g2, K_g, θ) * N\n    expected_counts[i] = bin_widths[i] * xg\n    observed_counts[i] = rand(Poisson(expected_counts[i]))\nend\n\nplot(bin_centers, [xgx(x, λ_g1, λ_g2, K_g, θ) for x in bin_centers] .* bin_widths * N,\n    alpha=0.7, label=\"Expected\", lw=3, color=\"red\")\nscatter!(bin_centers, observed_counts, lw=3, label=\"Observed\", color=\"black\")","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Store the data in a simple dict to pass to the likelihood later.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"data = Dict()\ndata[\"N\"] = N\ndata[\"bin_centers\"] = bin_centers;\ndata[\"observed_counts\"] = observed_counts;\ndata[\"bin_widths\"] = bin_widths;\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/#Fit","page":"Prior model implementation in BAT.jl","title":"Fit","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"To fit this example data, we choose a prior over our hyperparameters θ, λ_g1, λ_g2 and K_g.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We decide to choose a sensible Dirichlet prior, and have a look at some samples to help understand what this means.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"dirichlet = Dirichlet([1, 1])\ntest = rand(dirichlet, 1000)\nplot(append!(Histogram(0:0.1:1), test[1, :]))\nplot!(append!(Histogram(0:0.1:1), test[2, :]))","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"So, we see that this means all weights are equally likely for both components.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Now we can define the prior:","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"mathrmPrior - P(theta) P(lambda_g1) P(lambda_g2) P(K_g)","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"prior = NamedTupleDist(\n    θ = Dirichlet([1, 1]),\n    λ_g1 = Uniform(0, 1), #Truncated(Normal(0.7, 0.1), 0, 1)\n    λ_g2 = Uniform(-1, 0), #Truncated(Normal(-0.7, 0.1), -1, 0),\n    K_g =  Uniform(2, 10), # Truncated(Normal(1, 2), 2, 10),\n);\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Define a simple poisson likelihood that describes the test data that we generated above.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"likelihood = let d = data, f = xgx\n\n    observed_counts = d[\"observed_counts\"]\n    bin_centers = d[\"bin_centers\"]\n    bin_widths = d[\"bin_widths\"]\n    N = data[\"N\"]\n\n    logfuncdensity(function (params)\n        function bin_log_likelihood(i)\n            xg = f(\n                bin_centers[i], params.λ_g1, params.λ_g2, params.K_g, params.θ\n            )\n            expected_counts = bin_widths[i] * xg * N\n            logpdf(Poisson(expected_counts), observed_counts[i])\n        end\n\n        idxs = eachindex(observed_counts)\n        ll_value = bin_log_likelihood(idxs[1])\n        for i in idxs[2:end]\n            ll_value += bin_log_likelihood(i)\n        end\n\n        return ll_value\n    end)\nend","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"The prior and likelihood can be passed to BAT.jl via the PosteriorDensity. We can then sample this density using bat_sample().","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"posterior = PosteriorDensity(likelihood, prior);\nsamples = bat_sample(\n    posterior,\n    MCMCSampling(mcalg=MetropolisHastings(), nsteps=10^4, nchains=4)\n).result;\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"The SampledDensity gives a quick overview of the results.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"SampledDensity(posterior, samples)","category":"page"},{"location":"prior_bat_implementation/#Visualise-results","page":"Prior model implementation in BAT.jl","title":"Visualise results","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We can (roughly) check how well the fit reconstructs the truth with a simple comparison.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"x_grid = range(0, stop=1, length=50)\nsub_samples = bat_sample(samples, OrderedResampling(nsamples=200)).result\n\nplot()\nfor i in eachindex(sub_samples)\n    s = sub_samples[i].v\n    xg = [xgx(x, s.λ_g1, s.λ_g2, s.K_g, s.θ) for x in bin_centers]\n    plot!(bin_centers, xg .* bin_widths * N, alpha=0.1, lw=3,\n        color=\"darkorange\", label=\"\",)\nend\n\nxg = [xgx(x, λ_g1, λ_g2, K_g, θ) for x in bin_centers]\nplot!(bin_centers, xg .* bin_widths * N, alpha=0.7,\n    label=\"Expected\", lw=3, color=\"red\")\n\nscatter!(bin_centers, observed_counts, lw=3, label=\"Observed\", color=\"black\")\n\nplot!(xlabel=\"x\")","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"In the above plot, the red line represents the truth, and the set of fainter lines represent samples from the posterior.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We can also look at marginal distributions for different parameters...","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"plot(\n    samples, :(λ_g1),\n    mean = true, std = true,\n    nbins = 50,\n)","category":"page"},{"location":"prior_bat_implementation/#Full-model-with-all-components","page":"Prior model implementation in BAT.jl","title":"Full model with all components","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"We can now extend this approach to the full 9 components, there is not so much documentation here, as it follows the above case.","category":"page"},{"location":"prior_bat_implementation/#Forward-model-2","page":"Prior model implementation in BAT.jl","title":"Forward model","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Here the parametrisation of each component in decreasing order of importance. We also use the helper functions provided by PartonDensity to keep things tidy.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"using PartonDensity","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"pdf_params = PDFParameters(λ_u=0.7, K_u=4.0, λ_d=0.5, K_d=6.0,\n                           λ_g1=0.7, λ_g2=-0.4, K_g=6.0, λ_q=-0.5,\n                           weights=[1, 0.5, 0.3, 0.2, 0.1, 0.1, 0.1])","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Sanity check","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"int_xtotx(pdf_params)","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Plot true model","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"plot_input_pdfs(pdf_params)","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Generate example data","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"bins = 0.0:0.05:1.0\nbin_widths = bins[2:end] - bins[1:end-1]\nbin_centers = (bins[1:end-1] + bins[2:end]) / 2\n\nN = 1000\nnbins = size(bin_centers)[1]\n\nexpected_counts = zeros(nbins)\nobserved_counts = zeros(Integer, nbins)\nfor i in 1:nbins\n    xt = xtotx(bin_centers[i], pdf_params) * N\n    expected_counts[i] = bin_widths[i] * xt\n    observed_counts[i] = rand(Poisson(expected_counts[i]))\nend","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Plot data and expectation","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"plot(bin_centers, [xtotx(x, pdf_params) for x in bin_centers] .* bin_widths * N,\n     alpha=0.7, label=\"Expected\", lw=3, color=\"red\")\nscatter!(bin_centers, observed_counts, lw=3, label=\"Observed\", color=\"black\")","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Store the data","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"data = Dict()\ndata[\"N\"] = N\ndata[\"bin_centers\"] = bin_centers;\ndata[\"observed_counts\"] = observed_counts;\ndata[\"bin_widths\"] = bin_widths;\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/#Fit-2","page":"Prior model implementation in BAT.jl","title":"Fit","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Prior","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"prior = NamedTupleDist(\n    θ = Dirichlet(pdf_params.weights),\n    λ_u = Truncated(Normal(pdf_params.λ_u, 0.5), 0, 1), #  Uniform(0, 1),\n    K_u = Truncated(Normal(pdf_params.K_u, 1), 2, 10),\n    λ_d = Truncated(Normal(pdf_params.λ_d, 0.5), 0, 1), # Uniform(0, 1),\n    K_d = Truncated(Normal(pdf_params.K_d, 1), 2, 10),\n    λ_g1 = Truncated(Normal(pdf_params.λ_g1, 1), 0, 1),\n    λ_g2 = Truncated(Normal(pdf_params.λ_g2, 1), -1, 0),\n    K_g = Truncated(Normal(pdf_params.K_g, 1), 2, 10),\n    λ_q = Truncated(Normal(pdf_params.λ_q, 0.1), -1, 0),\n);\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Likelihood","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"likelihood = let d = data, f = xtotx\n\n    observed_counts = d[\"observed_counts\"]\n    bin_centers = d[\"bin_centers\"]\n    bin_widths = d[\"bin_widths\"]\n    N = data[\"N\"]\n\n    logfuncdensity(function (params)\n        function bin_log_likelihood(i)\n            xt = f(bin_centers[i], params.λ_u, params.K_u, params.λ_d, params.K_d,\n                    params.λ_g1, params.λ_g2, params.K_g, params.λ_q, Vector(params.θ))\n            expected_counts = bin_widths[i] * xt * N\n            if expected_counts < 0\n                expected_counts = 1e-3\n            end\n            logpdf(Poisson(expected_counts), observed_counts[i])\n        end\n\n        idxs = eachindex(observed_counts)\n        ll_value = bin_log_likelihood(idxs[1])\n        for i in idxs[2:end]\n            ll_value += bin_log_likelihood(i)\n        end\n\n        return ll_value\n    end)\nend","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"Run fit","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"The next steps are commented for now as this hangs for some reason in the doc builds...","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"#posterior = PosteriorDensity(likelihood, prior);\n#samples = bat_sample(posterior, MCMCSampling(mcalg=MetropolisHastings(), nsteps=10^4, nchains=2)).result;\nnothing #hide","category":"page"},{"location":"prior_bat_implementation/#Visualise-results-2","page":"Prior model implementation in BAT.jl","title":"Visualise results","text":"","category":"section"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"#x_grid = range(0, stop=1, length=50)\n#sub_samples = bat_sample(samples, OrderedResampling(nsamples=200)).result\n\n#plot()\n\"\"\"\nfor i in eachindex(sub_samples)\n    s = sub_samples[i].v\n    xt = [xtotx(x, s.λ_u, s.K_u, s.λ_d, s.K_d,\n            s.λ_g1, s.λ_g2, s.K_g, s.λ_q, Vector(s.θ)) for x in bin_centers]\n    plot!(bin_centers, xt .* bin_widths * N, alpha=0.1, lw=3,\n        color=\"darkorange\", label=\"\")\nend\n\"\"\"\n#xt = [xtotx(x, pdf_params) for x in bin_centers]\n#plot!(bin_centers, xt .* bin_widths * N, alpha=0.7, label=\"Expected\", lw=3, color=\"red\")\n\n#scatter!(bin_centers, observed_counts, lw=3, label=\"Observed\", color=\"black\")\n#plot!(xlabel=\"x\")\nnothing","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"These first results are promising. We can also try changing the input parameters and priors to explore the performance of the fit.","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"","category":"page"},{"location":"prior_bat_implementation/","page":"Prior model implementation in BAT.jl","title":"Prior model implementation in BAT.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/transfer_matrix.jl\"","category":"page"},{"location":"transfer_matrix/#Transfer-matrix","page":"Transfer matrix","title":"Transfer matrix","text":"","category":"section"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"Here is a short demonstration of how to access the ZEUS transfer matrix interface.","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"using PartonDensity, CSV, DelimitedFiles\n\neMPp = 1 # e+/e- switch 0/1","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"Read in an example integrated cross section","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"numbers_from_file = readdlm(\"data/HERAPDF20_NNLO_EIG_ePp.txt\")","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"List of integrated cross section values in 429 bins","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"integ_xsec = numbers_from_file[:,3]","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"Corresponding list of expected event numbers","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"prediction = get_pred_N(integ_xsec, eMPp);\n\ninteg_xsec[153]\n\nprediction[151]","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/pdf_parametrisation.jl\"","category":"page"},{"location":"pdf_parametrisation/#Input-PDF-parametrisation-and-priors","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"An important part of PDF fitting is defining a useful parametrisation for the PDF shapes, as well as meaningful prior distributions that encode our knowledge of the problem.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"In this notebook, we explore two different approaches:","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Full Dirichlet\nValence shape + Dirichlet","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"In the end, it seems like the latter option makes more sense for us and is therefore implemented elsewhere in the PartonDensity package. We demonstrate why below.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"using Distributions, Plots, SpecialFunctions, Printf\nconst sf = SpecialFunctions;\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/#\"Full-Dirichlet\"-approach","page":"Input PDF parametrisation and priors","title":"\"Full Dirichlet\" approach","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"A clean way to ensure the momentum sum rule would be to sample different contributions of the momentrum density integral from a Dirichlet distribution, then use these weights to set the parameters on the individual Beta distributions. However, in practice this is non-trvial as we also want to fix the normalisation of the number densities of the valance contributions.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"9 components of decreasing importance","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"dirichlet = Dirichlet([3., 2., 1, 0.5, 0.3, 0.2, 0.1, 0.1, 0.1])\ndata = rand(dirichlet, 1000);\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Have a look","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"plot()\nfor i in 1:9\n    histogram!(data[i,:], bins=range(0, stop=1, length=20), alpha=0.7)\nend\nplot!(xlabel=\"I_i = A_i B_i\")","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"This would be great as the sum rule is automatically conserved","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"sum(data, dims=1)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"But, it is non-trival to define valence params from this","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I = rand(dirichlet)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Valance u component","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_u = rand(Uniform(0, 1))\nK_u = rand(Uniform(0, 10))","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Integral of number density must = 2","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"A_u = 2 / sf.beta(λ_u, K_u+1)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"integral of momentum density can be fixed by I[1]","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I_1 = A_u * sf.beta(λ_u+1, K_u+1);\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Could use a root-finder to find Ku given I1 and λ_u... Could be nasty to sample from though...","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I_1 = 2 * (sf.beta(λ_u+1, K_u+1)/sf.beta(λ_u, K_u+1));\n\nusing Roots\n\nfunction func_to_solve(K_u)\n    return I_1 - 2 * (sf.beta(λ_u+1, K_u+1) / sf.beta(λ_u, K_u+1))\nend\n\nK_u ≈ find_zero(func_to_solve, (0, 10), Bisection())","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"While this approach might be nice, there are two issues in practice:","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"It is difficult to set sensible priors on lambda_u that imply priors on K_u, and similarly for lambda_d and K_d\nThe problem is overconstrained and we hav to use a root finder. This is rather fragile, and could fail for certain parameter combinations, such as we might find in a fit.","category":"page"},{"location":"pdf_parametrisation/#\"Valence-shape-Dirichlet\"-approach","page":"Input PDF parametrisation and priors","title":"\"Valence shape + Dirichlet\" approach","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"We can handle this more elegantly (maybe?) by specifying constraints on the valence params through the shape of their Beta distributions, then using a Dirichlet to specify the weights of the gluon and sea components. The problem here is it isn't clear how to specify that the d contribution must be less than the u contribution, but it is possible to do this indirectly through priors on the shape parameters. This will however require some further investigation.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"x = range(0, stop=1, length=50)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"High-level priors Looks like we maybe want to change lambda and K priors to boost these components","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_u = 0.7 #rand(Uniform(0, 1))\nK_u = 4 #rand(Uniform(2, 10))\nλ_d = 0.5 #rand(Uniform(0, 1))\nK_d = 6 #rand(Uniform(2, 10))\n\nu_V = Beta(λ_u, K_u+1)\nA_u = 2 / sf.beta(λ_u, K_u+1)\n\nd_V = Beta(λ_d, K_d+1)\nA_d = 1 / sf.beta(λ_d, K_d+1)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Integral contributions","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I_u = A_u * sf.beta(λ_u+1, K_u+1)\nI_d = A_d * sf.beta(λ_d+1, K_d+1)\n\nplot(x, x .* A_u .* x.^λ_u .* (1 .- x).^K_u * 2, alpha=0.7, label=\"x u(x)\", lw=3)\nplot!(x, x .* A_d .* x.^λ_d .* (1 .- x).^K_d, alpha=0.7, label=\"x d(x)\", lw=3)\nplot!(xlabel=\"x\", legend=:topright)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"@printf(\"I_u = %.2f\\n\", I_u)\n@printf(\"I_d = %.2f\\n\", I_d)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"The remaining 7 integrals can be dirichlet-sampled with decreasing importance","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"remaining = 1 - (I_u + I_d)\ndirichlet = Dirichlet([3., 2., 1, 0.5, 0.3, 0.2, 0.1])\nI = rand(dirichlet) * remaining;\nsum(I) ≈ remaining","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Gluon contributions","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_g1 = rand(Uniform(-1, 0))\nλ_g2 = rand(Uniform(0, 1))\nK_g = rand(Uniform(2, 10))\nA_g2 = I[1] / sf.beta(λ_g2+1, K_g+1)\nA_g1 = I[2] / sf.beta(λ_g1+1, 5+1);\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Sea quark contributions","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_q = rand(Uniform(-1, 0))\nA_ubar = I[3] / (2 * sf.beta(λ_q+1, 5+1))\nA_dbar = I[4] / (2 * sf.beta(λ_q+1, 5+1))\nA_s = I[5] / (2 * sf.beta(λ_q+1, 5+1))\nA_c = I[6] / (2 * sf.beta(λ_q+1, 5+1))\nA_b = I[7] / (2 * sf.beta(λ_q+1, 5+1));\n\ntotal = A_u * sf.beta(λ_u+1, K_u+1) + A_d * sf.beta(λ_d+1, K_d+1)\ntotal += A_g1 * sf.beta(λ_g1+1, 5+1) + A_g2 * sf.beta(λ_g2+1, K_g+1)\ntotal += 2 * (A_ubar + A_dbar + A_s + A_c + A_b) * sf.beta(λ_q+1, 5+1)\ntotal ≈ 1","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"x = 10 .^ range(-2, stop=0, length=500)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"How does it look?","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"xg2 = A_g2 * x.^λ_g2 .* (1 .- x).^K_g\nxg1 = A_g1 * x.^λ_g1 .* (1 .-x).^5\nplot(x, x .* A_u .* x.^λ_u .* (1 .- x).^K_u * 2, alpha=0.7, label=\"x u(x)\", lw=3)\nplot!(x, x .* A_d .* x.^λ_d .* (1 .- x).^K_d, alpha=0.7, label=\"x d(x)\", lw=3)\nplot!(x, xg1 + xg2, alpha=0.7, label=\"x g(x)\", lw=3)\nplot!(x, A_ubar * x.^λ_q .* (1.0 .- x).^5, alpha=0.7, label=\"x ubar(x)\", lw=3)\nplot!(x, A_dbar * x.^λ_q .* (1.0 .- x).^5, alpha=0.7, label=\"x dbar(x)\", lw=3)\nplot!(x, A_s * x.^λ_q .* (1.0 .- x).^5, alpha=0.7, label=\"x s(x)\", lw=3)\nplot!(x, A_c * x.^λ_q .* (1.0 .- x).^5, alpha=0.7, label=\"x c(x)\", lw=3)\nplot!(x, A_b * x.^λ_q .* (1.0 .-  x).^5, alpha=0.7, label=\"x b(x)\", lw=3)\nplot!(xlabel=\"x\", legend=:bottomleft, xscale=:log, ylims=(1e-8, 10), yscale=:log)","category":"page"},{"location":"pdf_parametrisation/#Prior-predictive-checks","page":"Input PDF parametrisation and priors","title":"Prior predictive checks","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"We can start to visualise the type of PDFs that are allowed by the combination of the choice of parametrisation and prior distributions with some simple prior predictive checks, as done below...","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"N = 100\nalpha = 0.03\ntotal = Array{Float64, 1}(undef, N)\nfirst = true\nleg = 0\n\nplot()\nfor i in 1:N\n\n    λ_u_i = rand(Uniform(0, 1))\n    K_u_i = rand(Uniform(2, 10))\n    λ_d_i = rand(Uniform(0, 1))\n    K_d_i = rand(Uniform(2, 10))\n    A_u_i = 2 / sf.beta(λ_u_i, K_u_i+1)\n    A_d_i = 1 / sf.beta(λ_d_i, K_d_i+1)\n    I_u_i = A_u * sf.beta(λ_u_i+1, K_u_i+1)\n    I_d_i = A_d * sf.beta(λ_d_i+1, K_d_i+1)\n    u_V_i = Beta(λ_u_i, K_u_i+1)\n    d_V_i = Beta(λ_d_i, K_d_i+1)\n\n    remaining_i = 1 - (I_u_i + I_d_i)\n    dirichlet_i = Dirichlet([3., 2., 1, 0.5, 0.3, 0.2, 0.1])\n    I_i = rand(dirichlet_i) * remaining_i\n\n    λ_g1_i = rand(Uniform(-1, 0))\n    λ_g2_i = rand(Uniform(0, 1))\n    K_g_i = rand(Uniform(2, 10))\n    A_g2_i = I_i[1] / sf.beta(λ_g2_i+1, K_g_i+1)\n    A_g1_i = I_i[2] / sf.beta(λ_g1_i+1, 5+1)\n\n    λ_q_i = rand(Uniform(-1, 0))\n    A_ubar_i = I_i[3] / (2 * sf.beta(λ_q_i+1, 5+1))\n    A_dbar_i = I_i[4] / (2 * sf.beta(λ_q_i+1, 5+1))\n    A_s_i = I_i[5] / (2 * sf.beta(λ_q_i+1, 5+1))\n    A_c_i = I_i[6] / (2 * sf.beta(λ_q_i+1, 5+1))\n    A_b_i = I_i[7] / (2 * sf.beta(λ_q_i+1, 5+1))\n\n    total[i] = A_u_i * sf.beta(λ_u_i+1, K_u_i+1) + A_d_i * sf.beta(λ_d_i+1, K_d_i+1)\n    total[i] += A_g1_i * sf.beta(λ_g1_i+1, 5+1) + A_g2_i * sf.beta(λ_g2_i+1, K_g_i+1)\n    total[i] += 2 * (A_ubar_i + A_dbar_i + A_s_i + A_c_i + A_b_i) * sf.beta(λ_q_i+1, 5+1)\n\n    xg2_i = A_g2_i * x.^λ_g2_i .* (1 .- x).^K_g_i\n    xg1_i = A_g1_i * x.^λ_g1_i .* (1 .- x).^5\n    plot!(x, [x .* A_u_i .* x.^λ_u_i .* (1 .- x).^K_u_i * 2], alpha=alpha, color=\"blue\", lw=3)\n    plot!(x, x .* A_d_i .* x.^λ_d_i .* (1 .- x).^K_d_i, alpha=alpha, color=\"orange\", lw=3)\n    plot!(x, xg1_i + xg2_i, alpha=alpha, color=\"green\", lw=3)\n    plot!(x, A_ubar_i * x.^λ_q_i .* (1 .- x).^5, alpha=alpha, color=\"red\", lw=3)\n    plot!(x, A_dbar_i * x.^λ_q_i .* (1 .- x).^5, alpha=alpha, color=\"purple\", lw=3)\n    plot!(x, A_s_i * x.^λ_q_i .* (1 .- x).^5, alpha=alpha, color=\"brown\", lw=3)\n    plot!(x, A_c_i * x.^λ_q_i .* (1 .- x).^5, alpha=alpha, color=\"pink\", lw=3)\n    plot!(x, A_b_i * x.^λ_q_i .* (1 .- x).^5, alpha=alpha, color=\"grey\", lw=3)\nend\n\nplot!(xlabel=\"x\", ylabel=\"x f(x)\", xscale=:log, legend=false,\n      ylims=(1e-8, 10), yscale=:log)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Looks like naive priors need some work...","category":"page"},{"location":"pdf_parametrisation/#PDF-Parametrisation-interface","page":"Input PDF parametrisation and priors","title":"PDF Parametrisation interface","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"PartonDensity provides a handy interface to the \"Valence shape + Dirichlet\" style parametrisation, as demonstrated here.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"using PartonDensity\n\nhyper_params = PDFParameters(λ_u=0.7, K_u=4.0, λ_d=0.5, K_d=6.0, λ_g1=0.7, λ_g2=-0.4,\n                             K_g=6.0, λ_q=-0.5, seed=5, weights=[1, 0.5, 0.3, 0.2, 0.1, 0.1, 0.1]);\n\nplot_input_pdfs(hyper_params)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"int_xtotx(hyper_params) ≈ 1","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/forward_model.jl\"","category":"page"},{"location":"forward_model/#Forward-model","page":"Forward model","title":"Forward model","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Here, we go through an example of simulating the full forward model, from the prior definition to the expected number of events in different bins of the detector response.","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"using QCDNUM, PartonDensity\nusing Plots, Printf, NaNMath, Parameters","category":"page"},{"location":"forward_model/#Define-input-PDFs","page":"Forward model","title":"Define input PDFs","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"weights = [1, 0.5, 0.3, 0.2, 0.1, 0.1, 0.1]\nhyper_params = PDFParameters(λ_u=0.7, K_u=4.0, λ_d=0.5, K_d=6.0, λ_g1=0.7, λ_g2=-0.4,\n                             K_g=6.0, λ_q=-0.5, seed=5, weights=weights);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Plot the input PDFs","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot_input_pdfs(hyper_params)","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Sanity check that sum = 1","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"int_xtotx(hyper_params) ≈ 1","category":"page"},{"location":"forward_model/#Define-QCDNUM-grids,-weights-and-settings","page":"Forward model","title":"Define QCDNUM grids, weights and settings","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"grid = QCDNUMGrid(x_min=[1.0e-3], x_weights=[1], nx=100,\n                  qq_bounds=[1.0e2, 3.0e4], qq_weights=[1.0, 1.0], nq=50, spline_interp=3)\n\nqcdnum_params = QCDNUMParameters(order=2, α_S=0.118, q0=100.0, grid=grid,\n                                 n_fixed_flav=5, iqc=1, iqb=1, iqt=1, weight_type=1);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Initialise and set key parameters","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.qcinit(-6, \"\")\nQCDNUM.setord(qcdnum_params.order)\nQCDNUM.setalf(qcdnum_params.α_S, qcdnum_params.q0)","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Build grids","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"g = qcdnum_params.grid\nQCDNUM.gxmake(g.x_min, g.x_weights, g.x_num_bounds, g.nx,\n              g.spline_interp);\nQCDNUM.gqmake(g.qq_bounds, g.qq_weights, g.qq_num_bounds, g.nq);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Define FFNS/VFNS","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.setcbt(qcdnum_params.n_fixed_flav, qcdnum_params.iqc,\n              qcdnum_params.iqb, qcdnum_params.iqt);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Build weight tables","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"nw = QCDNUM.fillwt(qcdnum_params.weight_type)\nnw = QCDNUM.zmfillw()","category":"page"},{"location":"forward_model/#Evolve-the-PDFs-using-QCDNUM","page":"Forward model","title":"Evolve the PDFs using QCDNUM","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Define input PDF function","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"See https://www.nikhef.nl/~h24/qcdnum-files/doc/qcdnum170115.pdf under evolfg","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"There are functions available to generate the necessary input PDF function in the correct format for QCDNUM.jl (see get_input_pdf_func()), along with the mapping between this input function and quark species (see input_pdf_map).","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Get function and wrap with c-style pointer","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"my_func = get_input_pdf_func(hyper_params)\ninput_pdf = @cfunction(my_func, Float64, (Ref{Int32}, Ref{Float64}))","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Find index of starting scale and evolve","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"iq0 = QCDNUM.iqfrmq(qcdnum_params.q0)\npdf_loc = 1\neps = QCDNUM.evolfg(pdf_loc, input_pdf, input_pdf_map, iq0)","category":"page"},{"location":"forward_model/#Define-necessary-splines-for-cross-section-calculation","page":"Forward model","title":"Define necessary splines for cross section calculation","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"For splines","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"splint_params = SPLINTParameters();\nquark_coeffs = QuarkCoefficients();\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Define initial spline","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.ssp_spinit(splint_params.nuser);\nia = QCDNUM.isp_s2make(splint_params.nsteps_x, splint_params.nsteps_q);\nxnd = QCDNUM.ssp_unodes(ia, splint_params.nnodes_x, 0);\nqnd = QCDNUM.ssp_vnodes(ia, splint_params.nnodes_q, 0);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Check nodes and erase","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.ssp_nprint(ia);\nQCDNUM.ssp_erase(ia);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Set nodes and fill spline with structure function","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"iaFLup = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaFLup, pdf_loc, quark_coeffs.proup, 1, 0.0);\n\niaF2up = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF2up, pdf_loc, quark_coeffs.proup, 2, 0.0);\n\niaF3up = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF3up, pdf_loc, quark_coeffs.valup, 3, 0.0);\n\niaFLdn = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaFLdn, pdf_loc, quark_coeffs.prodn, 1, 0.0);\n\niaF2dn = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF2dn, pdf_loc, quark_coeffs.prodn, 2, 0.0);\n\niaF3dn = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF3dn, 1, quark_coeffs.valdn, 3, 0.0);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"store spline addresses","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.ssp_uwrite(splint_params.spline_addresses.F2up, Float64(iaF2up));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F2dn, Float64(iaF2dn));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F3up, Float64(iaF3up));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F3dn, Float64(iaF3dn));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.FLup, Float64(iaFLup));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.FLdn, Float64(iaFLdn));\n\nmy_func = get_input_xsec_func()\ninput_xsec = @cfunction(my_func, Float64, (Ref{Int32}, Ref{Int32}, Ref{UInt8}))","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"xsec_on_grid = zeros(g.nx, g.nq);\n\nfor ix = 1:g.nx\n    for iq = 1:g.nq\n        xsec_on_grid[ix, iq] = _fun_xsec_i(ix, iq)\n    end\nend\n\nqcdnum_x_grid = QCDNUM.gxcopy(g.nx)\nqcdnum_qq_grid =  QCDNUM.gqcopy(g.nq)\np1 = heatmap(qcdnum_x_grid, qcdnum_qq_grid, NaNMath.log10.(xsec_on_grid[:, :]'))\nplot(p1, xlabel=\"x\", ylabel=\"q2\",\n     xaxis=:log, yaxis=:log)","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 4]),\n    label=\"Q2=141 (input scale)\", lw=3)\nplot!(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 22]), label=\"Q2=1152\", lw=3)\nplot!(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 35]), label=\"Q2=5233\", lw=3)\nplot!(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 41]), label=\"Q2=10523\", lw=3)\nplot!(xaxis=:log, legend=:bottomleft, xlabel=\"x\",\n    ylabel=\"log10(cross section spline input)\", ylims=(-7, 5))","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"set_lepcharge(1)\niaF_eP = QCDNUM.isp_s2make(1, 2);\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F_eP, Float64(iaF_eP));\nQCDNUM.ssp_s2fill(iaF_eP, input_xsec, splint_params.rscut);\n\nset_lepcharge(-1)\niaF_eM = QCDNUM.isp_s2make(1, 2);\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F_eM, Float64(iaF_eM));\nQCDNUM.ssp_s2fill(iaF_eM, input_xsec, splint_params.rscut);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot spline","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"spline = zeros(g.nx, g.nq);\n\nfor ix = 1:g.nx\n    for iq = 1:g.nq\n        spline[ix, iq] = QCDNUM.dsp_funs2(iaF_eP, qcdnum_x_grid[ix],\n            qcdnum_qq_grid[iq], 1)\n    end\nend\n\np1 = heatmap(qcdnum_x_grid, qcdnum_qq_grid, NaNMath.log10.(spline[:, :]'))\nplot(p1, xlabel=\"x\", ylabel=\"q2\",\n    xaxis=:log, yaxis=:log)","category":"page"},{"location":"forward_model/#Integrate-over-the-cross-section-spline-and-find-expected-events-numbers","page":"Forward model","title":"Integrate over the cross section spline and find expected events numbers","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"nbins = size(xbins_M_begin)[1]\nIntXsec_eP = zeros(nbins);\nIntXsec_eM = zeros(nbins);\nfor i in 1:nbins\n    IntXsec_eP[i] = QCDNUM.dsp_ints2(iaF_eP, xbins_M_begin[i], xbins_M_end[i],\n        q2bins_M_begin[i], q2bins_M_end[i], 318., 4);\n    IntXsec_eM[i] = QCDNUM.dsp_ints2(iaF_eM, xbins_M_begin[i], xbins_M_end[i],\n        q2bins_M_begin[i], q2bins_M_end[i], 318., 4);\nend","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"1 for e-p and 0 for e+p","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"ePp = 0;\neMp = 1;\n\nTM_eP = get_TM_elements(ePp);\nTM_eM = get_TM_elements(eMp);\n\nK_eP = get_K_elements(ePp);\nK_eM = get_K_elements(eMp);\n\nnbins_out = size(TM_eP)[2];\n\nxsec_pred_eP = zeros(nbins_out);\nxsec_pred_eM = zeros(nbins_out);\n\nfor j in 1:nbins_out\n\n    for i in 1:nbins\n\n        xsec_pred_eP[j] += TM_eP[i, j] * (1.0/K_eP[i]) * IntXsec_eP[i];\n        xsec_pred_eM[j] += TM_eM[i, j] * (1.0/K_eM[i]) * IntXsec_eM[i];\n\n    end\n\nend\n\nxsec_pred_eM","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/main/examples/full_bat_implementation.jl\"","category":"page"},{"location":"full_bat_implementation/#A-fit-with-BAT.jl","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"","category":"section"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"In this example we show how to bring the PDF parametrisation and forward model together with BAT.jl to perform a fit of simulated data. This fit is a work in progress and just a starting point for verification of the method.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"using BAT, DensityInterface\nusing PartonDensity\nusing QCDNUM\nusing Plots, Random, Distributions, ValueShapes, ParallelProcessingTools\nusing StatsBase, LinearAlgebra\n\ngr(fmt=:png);\nnothing #hide","category":"page"},{"location":"full_bat_implementation/#Simulate-some-data","page":"A fit with BAT.jl","title":"Simulate some data","text":"","category":"section"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"seed = 42\nRandom.seed!(seed) # for reproducibility","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"We can start off by simulating some fake data for us to fit. This way, we know exactly what initial conditions we have specified and can check the validity of our inference, assuming the generative model is the one that is producing our data.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"This is a good first check to work with.","category":"page"},{"location":"full_bat_implementation/#Specify-the-input-PDFs","page":"A fit with BAT.jl","title":"Specify the input PDFs","text":"","category":"section"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"See the Input PDF parametrisation and priors example for more information on the definition of the input PDFs.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"pdf_params = PDFParameters(λ_u=0.64, K_u=3.38, λ_d=0.67, K_d=4.73,\n    λ_g1=-0.59, λ_g2=-0.63, K_g=4.23, λ_q=-0.23, weights=[5., 5., 1., 1., 1., 0.5, 0.5]);\n\nplot_input_pdfs(pdf_params)","category":"page"},{"location":"full_bat_implementation/#Go-from-PDFs-to-counts-in-ZEUS-detector-bins","page":"A fit with BAT.jl","title":"Go from PDFs to counts in ZEUS detector bins","text":"","category":"section"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"Given the input PDFs, we can then evolve, calculate the cross sections, and fold through the ZEUS transfer matrix to get counts in bins. Here, we make use of some simple helper functions to do so. For more details, see the Forward model example.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"first specify QCDNUM inputs","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"qcdnum_grid = QCDNUMGrid(x_min=[1.0e-3], x_weights=[1], nx=100,\n    qq_bounds=[1.0e2, 3.0e4], qq_weights=[1.0, 1.0], nq=50, spline_interp=3)\nqcdnum_params = QCDNUMParameters(order=2, α_S=0.118, q0=100.0, grid=qcdnum_grid,\n    n_fixed_flav=5, iqc=1, iqb=1, iqt=1, weight_type=1);\nnothing #hide","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"now SPLINT and quark coefficients","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"splint_params = SPLINTParameters();\nquark_coeffs = QuarkCoefficients();\nnothing #hide","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"initialise QCDNUM","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"forward_model_init(qcdnum_grid, qcdnum_params, splint_params)","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"run forward model","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"counts_pred_ep, counts_pred_em = forward_model(pdf_params, qcdnum_params,\n    splint_params, quark_coeffs);\nnothing #hide","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"take a poisson sample","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"nbins = size(counts_pred_ep)[1]\ncounts_obs_ep = zeros(UInt64, nbins)\ncounts_obs_em = zeros(UInt64, nbins)\n\nfor i in 1:nbins\n    counts_obs_ep[i] = rand(Poisson(counts_pred_ep[i]))\n    counts_obs_em[i] = rand(Poisson(counts_pred_em[i]))\nend","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"plot(1:nbins, counts_pred_ep, label=\"Expected counts (eP)\", color=\"blue\")\nplot!(1:nbins, counts_pred_em, label=\"Expected counts (eM)\", color=\"red\")\nscatter!(1:nbins, counts_obs_ep, label=\"Detected counts (eP)\", color=\"blue\")\nscatter!(1:nbins, counts_obs_em, label=\"Detected counts (eM)\", color=\"red\")\nplot!(xlabel=\"Bin number\")","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"store","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"sim_data = Dict{String, Any}()\nsim_data[\"nbins\"] = nbins;\nsim_data[\"counts_obs_ep\"] = counts_obs_ep;\nsim_data[\"counts_obs_em\"] = counts_obs_em;\nnothing #hide","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"write to file","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"pd_write_sim(\"output/simulation.h5\", pdf_params, sim_data)","category":"page"},{"location":"full_bat_implementation/#Fit-the-simulated-data","page":"A fit with BAT.jl","title":"Fit the simulated data","text":"","category":"section"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"Now we can try to fit this simulated data using Bat.jl. The first step is to define the prior and likelihood. For now, let's try relatively narrow priors centred on the true values.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"prior = NamedTupleDist(\n    θ_tmp = Dirichlet(pdf_params.weights),\n    λ_u = Truncated(Normal(pdf_params.λ_u, 1), 0, 1),\n    K_u = Truncated(Normal(pdf_params.K_u, 1), 2, 10),\n    λ_d = Truncated(Normal(pdf_params.λ_d, 1), 0, 1),\n    K_d = Truncated(Normal(pdf_params.K_d, 1), 2, 10),\n    λ_g1 = Truncated(Normal(pdf_params.λ_g1, 1), -1, 0),\n    λ_g2 = Truncated(Normal(pdf_params.λ_g2, 1), -1, 0),\n    K_g =  Truncated(Normal(pdf_params.K_g, 1), 2, 10),\n    λ_q = Truncated(Normal(pdf_params.λ_q, 0.1), -1, 0),\n);\nnothing #hide","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"The likelihood is similar to that used in the input PDF parametrisation example. We start by accessing the current parameter set of the sampler's iteration, then running the forward model to get the predicted counts and comparing to the observed counts using a simple Poisson likelihood.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"The @critical macro is used because forward_model() is currently not thread safe, so this protects it from being run in parallel.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"likelihood = let d = sim_data\n\n    counts_obs_ep = d[\"counts_obs_ep\"]\n    counts_obs_em = d[\"counts_obs_em\"]\n    nbins = d[\"nbins\"]\n\n    logfuncdensity(function (params)\n\n            θ = get_scaled_θ(params.λ_u, params.K_u, params.λ_d,\n                             params.K_d, Vector(params.θ_tmp))\n\n            pdf_params = PDFParameters(λ_u=params.λ_u, K_u=params.K_u, λ_d=params.λ_d,\n                                       K_d=params.K_d, λ_g1=params.λ_g1, λ_g2=params.λ_g2,\n                                       K_g=params.K_g, λ_q=params.λ_q, θ=θ)\n\n            counts_pred_ep, counts_pred_em = @critical forward_model(pdf_params,\n                qcdnum_params, splint_params, quark_coeffs);\n\n            ll_value = 0.0\n            for i in 1:nbins\n\n                if counts_pred_ep[i] < 0\n                   #@warn \"counts_pred_ep[i] < 0, setting to 0\" i counts_pred_ep[i]\n                   counts_pred_ep[i] = 0\n                end\n\n                if counts_pred_em[i] < 0\n                   #@warn \"counts_pred_em[i] < 0, setting to 0\" i counts_pred_em[i]\n                   counts_pred_em[i] = 0\n                end\n\n                ll_value += logpdf(Poisson(counts_pred_ep[i]), counts_obs_ep[i])\n                ll_value += logpdf(Poisson(counts_pred_em[i]), counts_obs_em[i])\n            end\n\n            return ll_value\n    end)\nend","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"We can now run the MCMC sampler. We will start by using the Metropolis-Hastings algorithm as implemented in BAT.jl. To get reasonable results, we need to run the sampler for a long time (several hours). To save time in this demo, we will work with a ready-made results file. To actually run the sampler, simply uncomment the code below.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"#posterior = PosteriorDensity(likelihood, prior);\n#convergence = BrooksGelmanConvergence(threshold=1.3);\n#burnin = MCMCMultiCycleBurnin(max_ncycles=100);\n\n#samples = bat_sample(posterior, MCMCSampling(mcalg=MetropolisHastings(), nsteps=10^4, nchains=2)).result;\nnothing #hide","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"Alternatively, we could also try a nested sampling approach here for comparison. This is easily done thanks to the interface of BAT.jl, you will just need to add the NestedSamplers.jl package.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"#import NestedSamplers\n#samples = bat_sample(posterior, EllipsoidalNestedSampling()).result","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"If you run the sampler, be sure to save the results for further analysis","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"#import HDF5\n#bat_write(\"output/results.h5\", samples)","category":"page"},{"location":"full_bat_implementation/#Analysing-the-results","page":"A fit with BAT.jl","title":"Analysing the results","text":"","category":"section"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"First, let's load our simulation inputs and results","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"pdf_params, sim_data = pd_read_sim(\"output/simulation.h5\");\nsamples = bat_read(\"output/results.h5\").result;\nnothing #hide","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"We can check some diagnostics using built in BAT.jl, such as the effective sample size shown below","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"bat_eff_sample_size(unshaped.(samples))[1]","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"We see a value for each of our 15 total parameters. As the Metropolis-Hastings algorithm's default implementation isn't very efficient, we see that the effective sample size is only a small percentage of the input nsteps. We should try to improve this if possible, or use a much larger nsteps value.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"For demonstration purposes, we will continue to show how we can visualise the results in this case. For robust inference, we need to improve the sampling stage above.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"We can use BAT.jl's built in plotting recipes to show the marginals, for example, consider λ_u, and compare to the known truth.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"plot(\n    samples, :(λ_u),\n    nbins=50,\n    colors=[:skyblue4, :skyblue3, :skyblue1],\n    alpha=0.7,\n    marginalmode=false,\n    legend=:topleft\n)\nvline!([pdf_params.λ_u], color=\"black\", label=\"truth\", lw=3)","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"If we want to compare the momentum weights, we must transform from θtmp to θ, as shown below. Here, we transform using ```getscaled_θ()``, convert the result to a matrix, and access the ith weight with the integeri`","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"θ = [get_scaled_θ(λ_u, K_u, λ_d, K_d, Vector(θ_tmp)) for (λ_u, K_u, λ_d, K_d, θ_tmp)\n     in zip(samples.v.λ_u, samples.v.K_u, samples.v.λ_d, samples.v.K_d, samples.v.θ_tmp)];\n\nθ = transpose(reduce(vcat,transpose.(θ)))\n\ni = 1\nhist = append!(Histogram(0:0.02:1), θ[i,:])\nplot(\n    normalize(hist, mode=:density),\n    st = :steps, label=\"Marginal posterior\"\n)\nvline!([pdf_params.θ[i]], color=\"black\", label=\"truth\", lw=3)","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"Rather than making a large plot 15 different marginals, it can be more useful to visualise the posterior distribution in differently, such as the shape of the distributions we are trying to fit, or the model space. Helper functions exist for doing just this.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"Using BAT recipe","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"function wrap_xtotx(p::NamedTuple{(:K_d, :K_g, :K_u, :θ_tmp, :λ_d, :λ_g1,\n                                   :λ_g2, :λ_q, :λ_u)}, x::Real)\n    θ = get_scaled_θ(p.λ_u, p.K_u, p.λ_d, p.K_d, Vector(p.θ_tmp))\n    pdf_params = PDFParameters(λ_u=p.λ_u, K_u=p.K_u, λ_d=p.λ_d, K_d=p.K_d, λ_g1=p.λ_g1,\n        λ_g2=p.λ_g2, K_g=p.K_g, λ_q=p.λ_q, θ=θ)\n    return log(xtotx(x, pdf_params))\nend\n\nx_grid = range(1e-3, stop=1, length=50)\nplot(x_grid, wrap_xtotx, samples, colors=[:skyblue4, :skyblue3, :skyblue1],\n     legend=:topright)\nplot!(x_grid, [log(xtotx(x, pdf_params)) for x in x_grid], color=\"black\", lw=3,\n      label=\"Truth\", linestyle=:dash)\nplot!(ylabel=\"log(xtotx)\")","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"Using PartonDensity.jl","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"plot_model_space(pdf_params, samples)","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"Alternatively, we can also visualise the implications of the fit in the data space, as shown below.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"plot_data_space(pdf_params, sim_data, samples, qcdnum_grid, qcdnum_params,\n                splint_params, quark_coeffs)","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"The first results seem promising, but these are really just first checks and more work will have to be done to verify the method.","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"","category":"page"},{"location":"full_bat_implementation/","page":"A fit with BAT.jl","title":"A fit with BAT.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Bayesian approach to parton density extraction. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Hadrons, such as protons and neutrons, are made up of quarks held together by the strong force. At high energy scales, the valence quarks that define these hadrons exist in a sea of virtual quarks and gluons. The parton distribution functions (PDFs) describe this structure and are of fundamental importance to our understanding of quantum chromodynamics (QCD), as well as its application to LHC physics and the development of cosmic ray air showers in the Earth's atmosphere. PDFs can be extracted from accelerator measurements in which hadrons are probed through collisions with electrons. A limitation of existing approaches to analysing this data is the reliance on the chi-square statistic and the coupled assumption of Normal-distributed observations. We are working on a new statistical method for PDF extraction, which overcomes this limitation by forward modelling the problem from an input PDF to the expected number of events in a detector. This model will then be fit using Markov Chain Monte Carlo to enable inference of the PDF parameters. Our project builds on the QCDNUM software for fast QCD evolution and the Bayesian Analysis Toolkit developed at the ODSL to allow inference. We initially focus on the \"high-x\" regime, where the chi-square method cannot be used due to low event numbers.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package uses QCDNUM.jl for fast PDF evolution and cross-section calculation and BAT.jl for Bayesian inference.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To install PartonDensity.jl, start Julia and run","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/cescalara/PartonDensity.jl.git\")","category":"page"},{"location":"#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Check out the examples listed in these docs! The scripts can be found in the examples directory of the GitHub repository. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To run these docs, you can follow the steps used in the GitHub workflow. In particular, we need to remember to use the latest versions of QCDNUM.jl and BAT.jl from GitHub. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(url=\"https://github.com/bat/BAT.jl.git\")\nPkg.add(url=\"https://github.com/cescalara/QCDNUM.jl.git\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you want to convert the example scripts to notebooks, use Literate.jl.","category":"page"},{"location":"#Development","page":"Introduction","title":"Development","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Below are the installation instruction for those who wish to contribute to the code.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Clone the github repository, e.g. via the command line:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"git clone  https://github.com/cescalara/PartonDensity.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Enter the directory and start Julia interpreter","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"cd PartonDensity.jl\njulia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Open the Julia package management environment pressing ].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Execute ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> generate PartonDensity\n...... \npkg>  . dev","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Exit the package manager using backspace or pressing Ctrl+C","category":"page"}]
}
